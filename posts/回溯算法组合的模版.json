{"__ud_title":"回溯算法组合的模版","__ud_tags":["leetcode","回溯","组合"],"__ud_update_time":1733627174582,"__ud_create_time":1733627173013,"__ud_draft":false,"type":"doc","content":[{"type":"heading","attrs":{"level":1,"id":"回溯算法组合的模版"},"content":[{"type":"text","text":"回溯算法组合的模版"}]},{"type":"heading","attrs":{"level":2,"id":null},"content":[{"type":"text","text":"模版"}]},{"type":"paragraph","content":[{"type":"text","text":"回溯算法其实就是暴力算法，回溯是递归的副产品，我一般将回溯～=递归"}]},{"type":"paragraph","content":[{"type":"text","text":"回溯的函数一般用backtracking"}]},{"type":"codeBlock","attrs":{"language":"java"},"content":[{"type":"text","text":"//存放最终结果\nList<List<String>> res = new ArrayList<>();\n//存放回溯时的数据\nList<String> path = new ArrayList<>();\n  \nvoid backtracking(参数) {\n\tif(条件) {\n\t\t存放内容\n\t\treturn;\n\t}\n\tfor (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {\n    \t处理节点;\n\t    backtracking(路径，选择列表); // 递归\n    \t回溯，撤销处理结果\n\t}\n}"}]},{"type":"paragraph","content":[{"type":"text","text":"做题之前先把具体的树状图梳理出来再套模版，例如："}]},{"type":"image","attrs":{"src":"/post-assets/m4f0uvtg-image.png","alt":"image.png","title":null}},{"type":"paragraph","content":[{"type":"text","text":"横向遍历就是第一层for循环，纵向遍历是第一层for循环中每一次的循环，后续的继续执行"}]},{"type":"heading","attrs":{"level":2,"id":null},"content":[{"type":"text","text":"startIndex的选择"}]},{"type":"paragraph","content":[{"type":"text","text":"参数中什么时候需要startIndex？"}]},{"type":"paragraph","content":[{"type":"text","text":"对于单个集合遍历需要考虑startIndex，对多个集合的遍历[letter-combinations-of-a-phone-number]("},{"type":"text","marks":[{"type":"link","attrs":{"href":"https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/","target":"_blank","rel":"noopener noreferrer nofollow","class":null}}],"text":"https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/"},{"type":"text","text":")不需要使用"}]},{"type":"paragraph","content":[{"type":"text","text":"单个集合的话，参考上面的树状图，如果前面取值后，后续不能再取了，就需要startIndex；"}]},{"type":"heading","attrs":{"level":2,"id":null},"content":[{"type":"text","text":"集合中有重复元素"}]},{"type":"paragraph","content":[{"type":"text","text":"对于集合中存在重复元素，例如nums = [1,2,2]，这种情况下(1,第一个2), 和 (1,第二个2)是同一种情况"}]},{"type":"image","attrs":{"src":"/post-assets/m4f0uvtg-image.png","alt":"image.png","title":null}},{"type":"paragraph","content":[{"type":"text","text":"也就是同一数层上不能重复取，同一树枝上可以，直接"},{"type":"text","marks":[{"type":"bold"}],"text":"排序"}]},{"type":"codeBlock","attrs":{"language":"java"},"content":[{"type":"text","text":"Arrays.sort(nums);\n\nvoid backtracking(int[] nums, int startIndex) {\n\tfor(int i = startIndex; i < nums.length; i++) {\n\t\tif(i != startIndex && nums[i] == nums[i-1]) {\n\t\t\tcontinue;\n\t\t}\n\t}\t\n}"}]},{"type":"paragraph"},{"type":"paragraph"},{"type":"paragraph"}]}