{"__ud_title":"二叉树的遍历","__ud_tags":["二叉树"],"__ud_update_time":1734181001763,"__ud_create_time":1734168958143,"__ud_draft":false,"type":"doc","content":[{"type":"heading","attrs":{"level":1,"id":"二叉树的遍历"},"content":[{"type":"text","text":"二叉树的遍历"}]},{"type":"paragraph","content":[{"type":"text","text":"二叉树分为前序，中序，后序遍历和层次遍历"}]},{"type":"heading","attrs":{"level":2,"id":"递归遍历"},"content":[{"type":"text","text":"递归遍历"}]},{"type":"codeBlock","attrs":{"language":"java"},"content":[{"type":"text","text":"List<Integer> res = new ArrayList<>();\npublic List<Integer> order(TreeNode root) {\n\trecursion(root);\n\treturn res;\n}\n\n//前序模式\npublic void recursion(TreeNode root) {\n\tif(root == null) return;\n\tres.add(root.val);\n\tif(root.left != null) recursion(root.left);\n\tif(root.right != null) recursion(root.right);\n}\n\n//中序模式\npublic void recursion(TreeNode root) {\n\tif(root == null) return;\n\tif(root.left != null) recursion(root.left);\n\tres.add(root.val);\n\tif(root.right != null) recursion(root.right);\n}\n\n//后序模式\npublic void recursion(TreeNode root) {\n\tif(root == null) return;\n\tif(root.left != null) recursion(root.left);\n\tif(root.right != null) recursion(root.right);\n\tres.add(root.val);\n}"}]},{"type":"heading","attrs":{"level":2,"id":null},"content":[{"type":"text","text":"迭代遍历"}]},{"type":"paragraph","content":[{"type":"text","text":"前序遍历，中->左->右"}]},{"type":"paragraph","content":[{"type":"text","text":"用栈来存储node，栈是后入先出的，所以要先放root.right再放root.left"}]},{"type":"codeBlock","attrs":{"language":"java"},"content":[{"type":"text","text":"List<Integer> res = new ArrayList<>();\nstack.push(root);\nwhile(stack.size() > 0) {\n\tres.add(root.val);\n\tif(root.right != null) stack.push(root.right);\n\tif(root.left != null) stack.push(root.left);\n}"}]},{"type":"paragraph","content":[{"type":"text","text":"中序遍历，左->中->右"}]},{"type":"paragraph","content":[{"type":"text","text":"按照遍历的规则"}]},{"type":"orderedList","attrs":{"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","content":[{"type":"text","text":"一直找左节点直到为空为止"}]}]},{"type":"listItem","content":[{"type":"paragraph","content":[{"type":"text","text":"然后取出最左边的节点后找它的右节点"}]}]},{"type":"listItem","content":[{"type":"paragraph","content":[{"type":"text","text":"重复1的步骤"}]}]}]},{"type":"codeBlock","attrs":{"language":"java"},"content":[{"type":"text","text":"List<Integer> res = new ArrayList<>();\nTreeNode node = root;\nwhile(stack.size() > 0 || node != null) {\n\tif(node != null) {\n\t\tstack.push(node);\n\t\tnode = node.left;\n\t} else {\n\t\tTreeNode top = stack.pop();\n\t\tres.add(top.val);\n\t\tnode = node.right;\n\t}\n}"}]},{"type":"paragraph","content":[{"type":"text","text":"后序遍历"}]},{"type":"paragraph","content":[{"type":"text","text":"顺序是 左->右->中，可以看出它是中->右->左反过来，所以先用中->右->左，最后再反转数组就行"}]},{"type":"codeBlock","attrs":{"language":"java"},"content":[{"type":"text","text":"List<Integer> res = new ArrayList<>();\nstack.push(root);\nwhile(stack.size() > 0) {\n\tres.add(root.val);\n\tif(root.left != null) stack.push(root.left);\n\tif(root.right != null) stack.push(root.right);\n}\nCollections.reverse(res);"}]},{"type":"paragraph"}]}