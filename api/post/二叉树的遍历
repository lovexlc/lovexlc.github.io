{"content":"{\"__ud_title\":\"二叉树的遍历\",\"__ud_tags\":[\"二叉树\"],\"__ud_update_time\":1734181001763,\"__ud_create_time\":1734168958143,\"__ud_draft\":false,\"type\":\"doc\",\"content\":[{\"type\":\"heading\",\"attrs\":{\"level\":1,\"id\":\"二叉树的遍历\"},\"content\":[{\"type\":\"text\",\"text\":\"二叉树的遍历\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"二叉树分为前序，中序，后序遍历和层次遍历\"}]},{\"type\":\"heading\",\"attrs\":{\"level\":2,\"id\":\"递归遍历\"},\"content\":[{\"type\":\"text\",\"text\":\"递归遍历\"}]},{\"type\":\"codeBlock\",\"attrs\":{\"language\":\"java\"},\"content\":[{\"type\":\"text\",\"text\":\"List<Integer> res = new ArrayList<>();\\npublic List<Integer> order(TreeNode root) {\\n\\trecursion(root);\\n\\treturn res;\\n}\\n\\n//前序模式\\npublic void recursion(TreeNode root) {\\n\\tif(root == null) return;\\n\\tres.add(root.val);\\n\\tif(root.left != null) recursion(root.left);\\n\\tif(root.right != null) recursion(root.right);\\n}\\n\\n//中序模式\\npublic void recursion(TreeNode root) {\\n\\tif(root == null) return;\\n\\tif(root.left != null) recursion(root.left);\\n\\tres.add(root.val);\\n\\tif(root.right != null) recursion(root.right);\\n}\\n\\n//后序模式\\npublic void recursion(TreeNode root) {\\n\\tif(root == null) return;\\n\\tif(root.left != null) recursion(root.left);\\n\\tif(root.right != null) recursion(root.right);\\n\\tres.add(root.val);\\n}\"}]},{\"type\":\"heading\",\"attrs\":{\"level\":2,\"id\":null},\"content\":[{\"type\":\"text\",\"text\":\"迭代遍历\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"前序遍历，中->左->右\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"用栈来存储node，栈是后入先出的，所以要先放root.right再放root.left\"}]},{\"type\":\"codeBlock\",\"attrs\":{\"language\":\"java\"},\"content\":[{\"type\":\"text\",\"text\":\"List<Integer> res = new ArrayList<>();\\nstack.push(root);\\nwhile(stack.size() > 0) {\\n\\tres.add(root.val);\\n\\tif(root.right != null) stack.push(root.right);\\n\\tif(root.left != null) stack.push(root.left);\\n}\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"中序遍历，左->中->右\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"按照遍历的规则\"}]},{\"type\":\"orderedList\",\"attrs\":{\"start\":1},\"content\":[{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"一直找左节点直到为空为止\"}]}]},{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"然后取出最左边的节点后找它的右节点\"}]}]},{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"重复1的步骤\"}]}]}]},{\"type\":\"codeBlock\",\"attrs\":{\"language\":\"java\"},\"content\":[{\"type\":\"text\",\"text\":\"List<Integer> res = new ArrayList<>();\\nTreeNode node = root;\\nwhile(stack.size() > 0 || node != null) {\\n\\tif(node != null) {\\n\\t\\tstack.push(node);\\n\\t\\tnode = node.left;\\n\\t} else {\\n\\t\\tTreeNode top = stack.pop();\\n\\t\\tres.add(top.val);\\n\\t\\tnode = node.right;\\n\\t}\\n}\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"后序遍历\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"顺序是 左->右->中，可以看出它是中->右->左反过来，所以先用中->右->左，最后再反转数组就行\"}]},{\"type\":\"codeBlock\",\"attrs\":{\"language\":\"java\"},\"content\":[{\"type\":\"text\",\"text\":\"List<Integer> res = new ArrayList<>();\\nstack.push(root);\\nwhile(stack.size() > 0) {\\n\\tres.add(root.val);\\n\\tif(root.left != null) stack.push(root.left);\\n\\tif(root.right != null) stack.push(root.right);\\n}\\nCollections.reverse(res);\"}]},{\"type\":\"paragraph\"}]}","title":"二叉树的遍历","tags":["二叉树"],"updateTime":1734181001763,"createTime":1734168958143,"draft":false,"intro":"二叉树分为前序，中序，后序遍历和层次遍历","html":"<h1 level=\"1\" id=\"二叉树的遍历\">二叉树的遍历</h1><p>二叉树分为前序，中序，后序遍历和层次遍历</p><h2 level=\"2\" id=\"递归遍历\">递归遍历</h2><div class=\"llt-code readonly\"><div class=\"language\">java</div><div class=\"wrapper\"><pre><code class=\"language-java\">List&lt;Integer&gt; res = <span class=\"hljs-keyword\" class=\"hljs-keyword\">new</span> <span class=\"hljs-title,class_\" class=\"hljs-title,class_\">ArrayList</span>&lt;&gt;();\n<span class=\"hljs-keyword\" class=\"hljs-keyword\">public</span> List&lt;Integer&gt; <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">order</span><span class=\"hljs-params\" class=\"hljs-params\">(TreeNode root)</span> {\n\trecursion(root);\n\t<span class=\"hljs-keyword\" class=\"hljs-keyword\">return</span> res;\n}\n\n<span class=\"hljs-comment\" class=\"hljs-comment\">//前序模式</span>\n<span class=\"hljs-keyword\" class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\" class=\"hljs-keyword\">void</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">recursion</span><span class=\"hljs-params\" class=\"hljs-params\">(TreeNode root)</span> {\n\t<span class=\"hljs-keyword\" class=\"hljs-keyword\">if</span>(root == <span class=\"hljs-literal\" class=\"hljs-literal\">null</span>) <span class=\"hljs-keyword\" class=\"hljs-keyword\">return</span>;\n\tres.add(root.val);\n\t<span class=\"hljs-keyword\" class=\"hljs-keyword\">if</span>(root.left != <span class=\"hljs-literal\" class=\"hljs-literal\">null</span>) recursion(root.left);\n\t<span class=\"hljs-keyword\" class=\"hljs-keyword\">if</span>(root.right != <span class=\"hljs-literal\" class=\"hljs-literal\">null</span>) recursion(root.right);\n}\n\n<span class=\"hljs-comment\" class=\"hljs-comment\">//中序模式</span>\n<span class=\"hljs-keyword\" class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\" class=\"hljs-keyword\">void</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">recursion</span><span class=\"hljs-params\" class=\"hljs-params\">(TreeNode root)</span> {\n\t<span class=\"hljs-keyword\" class=\"hljs-keyword\">if</span>(root == <span class=\"hljs-literal\" class=\"hljs-literal\">null</span>) <span class=\"hljs-keyword\" class=\"hljs-keyword\">return</span>;\n\t<span class=\"hljs-keyword\" class=\"hljs-keyword\">if</span>(root.left != <span class=\"hljs-literal\" class=\"hljs-literal\">null</span>) recursion(root.left);\n\tres.add(root.val);\n\t<span class=\"hljs-keyword\" class=\"hljs-keyword\">if</span>(root.right != <span class=\"hljs-literal\" class=\"hljs-literal\">null</span>) recursion(root.right);\n}\n\n<span class=\"hljs-comment\" class=\"hljs-comment\">//后序模式</span>\n<span class=\"hljs-keyword\" class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\" class=\"hljs-keyword\">void</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">recursion</span><span class=\"hljs-params\" class=\"hljs-params\">(TreeNode root)</span> {\n\t<span class=\"hljs-keyword\" class=\"hljs-keyword\">if</span>(root == <span class=\"hljs-literal\" class=\"hljs-literal\">null</span>) <span class=\"hljs-keyword\" class=\"hljs-keyword\">return</span>;\n\t<span class=\"hljs-keyword\" class=\"hljs-keyword\">if</span>(root.left != <span class=\"hljs-literal\" class=\"hljs-literal\">null</span>) recursion(root.left);\n\t<span class=\"hljs-keyword\" class=\"hljs-keyword\">if</span>(root.right != <span class=\"hljs-literal\" class=\"hljs-literal\">null</span>) recursion(root.right);\n\tres.add(root.val);\n}</code></pre></div></div><h2 level=\"2\" id=\"迭代遍历\">迭代遍历</h2><p>前序遍历，中-&gt;左-&gt;右</p><p>用栈来存储node，栈是后入先出的，所以要先放root.right再放root.left</p><div class=\"llt-code readonly\"><div class=\"language\">java</div><div class=\"wrapper\"><pre><code class=\"language-java\">List&lt;Integer&gt; res = <span class=\"hljs-keyword\" class=\"hljs-keyword\">new</span> <span class=\"hljs-title,class_\" class=\"hljs-title,class_\">ArrayList</span>&lt;&gt;();\nstack.push(root);\n<span class=\"hljs-keyword\" class=\"hljs-keyword\">while</span>(stack.size() &gt; <span class=\"hljs-number\" class=\"hljs-number\">0</span>) {\n\tres.add(root.val);\n\t<span class=\"hljs-keyword\" class=\"hljs-keyword\">if</span>(root.right != <span class=\"hljs-literal\" class=\"hljs-literal\">null</span>) stack.push(root.right);\n\t<span class=\"hljs-keyword\" class=\"hljs-keyword\">if</span>(root.left != <span class=\"hljs-literal\" class=\"hljs-literal\">null</span>) stack.push(root.left);\n}</code></pre></div></div><p>中序遍历，左-&gt;中-&gt;右</p><p>按照遍历的规则</p><ol><li><p>一直找左节点直到为空为止</p></li><li><p>然后取出最左边的节点后找它的右节点</p></li><li><p>重复1的步骤</p></li></ol><div class=\"llt-code readonly\"><div class=\"language\">java</div><div class=\"wrapper\"><pre><code class=\"language-java\">List&lt;Integer&gt; res = <span class=\"hljs-keyword\" class=\"hljs-keyword\">new</span> <span class=\"hljs-title,class_\" class=\"hljs-title,class_\">ArrayList</span>&lt;&gt;();\n<span class=\"hljs-type\" class=\"hljs-type\">TreeNode</span> <span class=\"hljs-variable\" class=\"hljs-variable\">node</span> <span class=\"hljs-operator\" class=\"hljs-operator\">=</span> root;\n<span class=\"hljs-keyword\" class=\"hljs-keyword\">while</span>(stack.size() &gt; <span class=\"hljs-number\" class=\"hljs-number\">0</span> || node != <span class=\"hljs-literal\" class=\"hljs-literal\">null</span>) {\n\t<span class=\"hljs-keyword\" class=\"hljs-keyword\">if</span>(node != <span class=\"hljs-literal\" class=\"hljs-literal\">null</span>) {\n\t\tstack.push(node);\n\t\tnode = node.left;\n\t} <span class=\"hljs-keyword\" class=\"hljs-keyword\">else</span> {\n\t\t<span class=\"hljs-type\" class=\"hljs-type\">TreeNode</span> <span class=\"hljs-variable\" class=\"hljs-variable\">top</span> <span class=\"hljs-operator\" class=\"hljs-operator\">=</span> stack.pop();\n\t\tres.add(top.val);\n\t\tnode = node.right;\n\t}\n}</code></pre></div></div><p>后序遍历</p><p>顺序是 左-&gt;右-&gt;中，可以看出它是中-&gt;右-&gt;左反过来，所以先用中-&gt;右-&gt;左，最后再反转数组就行</p><div class=\"llt-code readonly\"><div class=\"language\">java</div><div class=\"wrapper\"><pre><code class=\"language-java\">List&lt;Integer&gt; res = <span class=\"hljs-keyword\" class=\"hljs-keyword\">new</span> <span class=\"hljs-title,class_\" class=\"hljs-title,class_\">ArrayList</span>&lt;&gt;();\nstack.push(root);\n<span class=\"hljs-keyword\" class=\"hljs-keyword\">while</span>(stack.size() &gt; <span class=\"hljs-number\" class=\"hljs-number\">0</span>) {\n\tres.add(root.val);\n\t<span class=\"hljs-keyword\" class=\"hljs-keyword\">if</span>(root.left != <span class=\"hljs-literal\" class=\"hljs-literal\">null</span>) stack.push(root.left);\n\t<span class=\"hljs-keyword\" class=\"hljs-keyword\">if</span>(root.right != <span class=\"hljs-literal\" class=\"hljs-literal\">null</span>) stack.push(root.right);\n}\nCollections.reverse(res);</code></pre></div></div><p></p><script type=\"module\">const injectHtml = (root, html) => {\n  const iframe = document.createElement(\"iframe\");\n  const htmlContent = `<html><head></head><body>${html}</body></html>`;\n  iframe.style.width = \"100%\";\n  iframe.style.height = \"100%\";\n  iframe.onload = () => {\n    const doc = iframe.contentDocument || iframe.contentWindow?.document;\n    if (!doc) {\n      return;\n    }\n    doc.open();\n    doc.write(htmlContent);\n    doc.close();\n  };\n  root.replaceChildren(iframe);\n}\n  document.querySelectorAll('.playground')?.forEach(el=>{\n    const html = el.getAttribute('data-html');\n    if (html) {\n      injectHtml(el,html);\n    }\n    const indicator = document.createElement(\"div\");\n    indicator.className = \"indicator\";\n    const showCode = document.createElement(\"div\");\n    showCode.className = \"show-code\";\n    showCode.innerText = \"code\";\n    showCode.onclick = () => {\n      el.parentElement.classList.remove(\"preview-only\");\n    };\n    const showPreview = document.createElement(\"div\");\n    showPreview.className = \"show-preview\";\n    showPreview.innerText = \"preview\";\n    showPreview.onclick = () => {\n      el.parentElement.classList.add(\"preview-only\");\n    };\n    indicator.appendChild(showCode);\n    indicator.appendChild(showPreview);\n    el.parentElement.appendChild(indicator);\n    if (window.screen.width < 768) {\n      showPreview.click();\n    }\n  });</script>","id":"二叉树的遍历","path":"/posts/二叉树的遍历.json"}