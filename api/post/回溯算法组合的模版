{"content":"{\"__ud_title\":\"回溯算法组合的模版\",\"__ud_tags\":[\"leetcode\",\"回溯\",\"组合\"],\"__ud_update_time\":1733627174582,\"__ud_create_time\":1733627173013,\"__ud_draft\":false,\"type\":\"doc\",\"content\":[{\"type\":\"heading\",\"attrs\":{\"level\":1,\"id\":\"回溯算法组合的模版\"},\"content\":[{\"type\":\"text\",\"text\":\"回溯算法组合的模版\"}]},{\"type\":\"heading\",\"attrs\":{\"level\":2,\"id\":null},\"content\":[{\"type\":\"text\",\"text\":\"模版\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"回溯算法其实就是暴力算法，回溯是递归的副产品，我一般将回溯～=递归\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"回溯的函数一般用backtracking\"}]},{\"type\":\"codeBlock\",\"attrs\":{\"language\":\"java\"},\"content\":[{\"type\":\"text\",\"text\":\"//存放最终结果\\nList<List<String>> res = new ArrayList<>();\\n//存放回溯时的数据\\nList<String> path = new ArrayList<>();\\n  \\nvoid backtracking(参数) {\\n\\tif(条件) {\\n\\t\\t存放内容\\n\\t\\treturn;\\n\\t}\\n\\tfor (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {\\n    \\t处理节点;\\n\\t    backtracking(路径，选择列表); // 递归\\n    \\t回溯，撤销处理结果\\n\\t}\\n}\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"做题之前先把具体的树状图梳理出来再套模版，例如：\"}]},{\"type\":\"image\",\"attrs\":{\"src\":\"/post-assets/m4f0uvtg-image.png\",\"alt\":\"image.png\",\"title\":null}},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"横向遍历就是第一层for循环，纵向遍历是第一层for循环中每一次的循环，后续的继续执行\"}]},{\"type\":\"heading\",\"attrs\":{\"level\":2,\"id\":null},\"content\":[{\"type\":\"text\",\"text\":\"startIndex的选择\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"参数中什么时候需要startIndex？\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"对于单个集合遍历需要考虑startIndex，对多个集合的遍历[letter-combinations-of-a-phone-number](\"},{\"type\":\"text\",\"marks\":[{\"type\":\"link\",\"attrs\":{\"href\":\"https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/\",\"target\":\"_blank\",\"rel\":\"noopener noreferrer nofollow\",\"class\":null}}],\"text\":\"https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/\"},{\"type\":\"text\",\"text\":\")不需要使用\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"单个集合的话，参考上面的树状图，如果前面取值后，后续不能再取了，就需要startIndex；\"}]},{\"type\":\"heading\",\"attrs\":{\"level\":2,\"id\":null},\"content\":[{\"type\":\"text\",\"text\":\"集合中有重复元素\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"对于集合中存在重复元素，例如nums = [1,2,2]，这种情况下(1,第一个2), 和 (1,第二个2)是同一种情况\"}]},{\"type\":\"image\",\"attrs\":{\"src\":\"/post-assets/m4f0uvtg-image.png\",\"alt\":\"image.png\",\"title\":null}},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"也就是同一数层上不能重复取，同一树枝上可以，直接\"},{\"type\":\"text\",\"marks\":[{\"type\":\"bold\"}],\"text\":\"排序\"}]},{\"type\":\"codeBlock\",\"attrs\":{\"language\":\"java\"},\"content\":[{\"type\":\"text\",\"text\":\"Arrays.sort(nums);\\n\\nvoid backtracking(int[] nums, int startIndex) {\\n\\tfor(int i = startIndex; i < nums.length; i++) {\\n\\t\\tif(i != startIndex && nums[i] == nums[i-1]) {\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t}\\t\\n}\"}]},{\"type\":\"paragraph\"},{\"type\":\"paragraph\"},{\"type\":\"paragraph\"}]}","title":"回溯算法组合的模版","tags":["leetcode","回溯","组合"],"updateTime":1733627174582,"createTime":1733627173013,"draft":false,"intro":"回溯算法其实就是暴力算法，回溯是递归的副产品，我一般将回溯～=递归","html":"<h1 level=\"1\" id=\"回溯算法组合的模版\">回溯算法组合的模版</h1><h2 level=\"2\" id=\"模版\">模版</h2><p>回溯算法其实就是暴力算法，回溯是递归的副产品，我一般将回溯～=递归</p><p>回溯的函数一般用backtracking</p><div class=\"llt-code readonly\"><div class=\"language\">java</div><div class=\"wrapper\"><pre><code class=\"language-java\"><span class=\"hljs-comment\" class=\"hljs-comment\">//存放最终结果</span>\nList&lt;List&lt;String&gt;&gt; res = <span class=\"hljs-keyword\" class=\"hljs-keyword\">new</span> <span class=\"hljs-title,class_\" class=\"hljs-title,class_\">ArrayList</span>&lt;&gt;();\n<span class=\"hljs-comment\" class=\"hljs-comment\">//存放回溯时的数据</span>\nList&lt;String&gt; path = <span class=\"hljs-keyword\" class=\"hljs-keyword\">new</span> <span class=\"hljs-title,class_\" class=\"hljs-title,class_\">ArrayList</span>&lt;&gt;();\n  \n<span class=\"hljs-keyword\" class=\"hljs-keyword\">void</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">backtracking</span><span class=\"hljs-params\" class=\"hljs-params\">(参数)</span> {\n\t<span class=\"hljs-keyword\" class=\"hljs-keyword\">if</span>(条件) {\n\t\t存放内容\n\t\t<span class=\"hljs-keyword\" class=\"hljs-keyword\">return</span>;\n\t}\n\t<span class=\"hljs-keyword\" class=\"hljs-keyword\">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {\n    \t处理节点;\n\t    backtracking(路径，选择列表); <span class=\"hljs-comment\" class=\"hljs-comment\">// 递归</span>\n    \t回溯，撤销处理结果\n\t}\n}</code></pre></div></div><p>做题之前先把具体的树状图梳理出来再套模版，例如：</p><img src=\"/post-assets/m4f0uvtg-image.png\" alt=\"image.png\"><p>横向遍历就是第一层for循环，纵向遍历是第一层for循环中每一次的循环，后续的继续执行</p><h2 level=\"2\" id=\"startIndex的选择\">startIndex的选择</h2><p>参数中什么时候需要startIndex？</p><p>对于单个集合遍历需要考虑startIndex，对多个集合的遍历[letter-combinations-of-a-phone-number](<a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/\">https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/</a>)不需要使用</p><p>单个集合的话，参考上面的树状图，如果前面取值后，后续不能再取了，就需要startIndex；</p><h2 level=\"2\" id=\"集合中有重复元素\">集合中有重复元素</h2><p>对于集合中存在重复元素，例如nums = [1,2,2]，这种情况下(1,第一个2), 和 (1,第二个2)是同一种情况</p><img src=\"/post-assets/m4f0uvtg-image.png\" alt=\"image.png\"><p>也就是同一数层上不能重复取，同一树枝上可以，直接<strong>排序</strong></p><div class=\"llt-code readonly\"><div class=\"language\">java</div><div class=\"wrapper\"><pre><code class=\"language-java\">Arrays.sort(nums);\n\n<span class=\"hljs-keyword\" class=\"hljs-keyword\">void</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">backtracking</span><span class=\"hljs-params\" class=\"hljs-params\">(<span class=\"hljs-type\" class=\"hljs-type\">int</span>[] nums, <span class=\"hljs-type\" class=\"hljs-type\">int</span> startIndex)</span> {\n\t<span class=\"hljs-keyword\" class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\" class=\"hljs-type\">int</span> <span class=\"hljs-variable\" class=\"hljs-variable\">i</span> <span class=\"hljs-operator\" class=\"hljs-operator\">=</span> startIndex; i &lt; nums.length; i++) {\n\t\t<span class=\"hljs-keyword\" class=\"hljs-keyword\">if</span>(i != startIndex &amp;&amp; nums[i] == nums[i-<span class=\"hljs-number\" class=\"hljs-number\">1</span>]) {\n\t\t\t<span class=\"hljs-keyword\" class=\"hljs-keyword\">continue</span>;\n\t\t}\n\t}\t\n}</code></pre></div></div><p></p><p></p><p></p><script type=\"module\">const injectHtml = (root, html) => {\n  const iframe = document.createElement(\"iframe\");\n  const htmlContent = `<html><head></head><body>${html}</body></html>`;\n  iframe.style.width = \"100%\";\n  iframe.style.height = \"100%\";\n  iframe.onload = () => {\n    const doc = iframe.contentDocument || iframe.contentWindow?.document;\n    if (!doc) {\n      return;\n    }\n    doc.open();\n    doc.write(htmlContent);\n    doc.close();\n  };\n  root.replaceChildren(iframe);\n}\n  document.querySelectorAll('.playground')?.forEach(el=>{\n    const html = el.getAttribute('data-html');\n    if (html) {\n      injectHtml(el,html);\n    }\n    const indicator = document.createElement(\"div\");\n    indicator.className = \"indicator\";\n    const showCode = document.createElement(\"div\");\n    showCode.className = \"show-code\";\n    showCode.innerText = \"code\";\n    showCode.onclick = () => {\n      el.parentElement.classList.remove(\"preview-only\");\n    };\n    const showPreview = document.createElement(\"div\");\n    showPreview.className = \"show-preview\";\n    showPreview.innerText = \"preview\";\n    showPreview.onclick = () => {\n      el.parentElement.classList.add(\"preview-only\");\n    };\n    indicator.appendChild(showCode);\n    indicator.appendChild(showPreview);\n    el.parentElement.appendChild(indicator);\n    if (window.screen.width < 768) {\n      showPreview.click();\n    }\n  });</script>","cover":{"src":"/post-assets/m4f0uvtg-image.png","alt":"image.png","title":null},"id":"回溯算法组合的模版","path":"/posts/回溯算法组合的模版.json"}